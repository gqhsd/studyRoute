# 从Paxos到zookeeper的原理和实践

## 分布式架构

### 常见问题

1. 通信异常

   网络延时比单机慢很多->消息丢失和消息延迟变得非常普遍

2. 网络分区

   网络分区会导致整体分布式系统出现局部小集群,独立完成整个分布式系统才能完成的事情,包括分布式事务处理->分布式一致性的挑战

3. 三态

   即一个函数的调用会有三种情况->成功 失败 超时

   超时的原因大致两点:

   1. 消息没到接收方
   2. 消息从接收方回来没到发送方

### CAP/BASE理论

**CAP理论**告诉我们，一个分布式系统不可能同时满足**一致性、 可用性和分区容错性**这三个基本需求，最多只能同时满足其中的两项。

- **一致性**:分布式环境下,数据的多个副本能不能保证一致性

  强一致性:一个数据项更新,所有用户读取的都是最新的值

- **可用性**:服务可用,用户的每个请求都能在**有限时间返回结果**

- **分区容错性**:要求系统在遇到网络分区故障的时候,依然可以提供满足一致性和可用性的服务

放弃 :

- 分区容错性:简单的做法就是程序放在同一个节点,自然不会出现网络分区,不过这也就放弃了高可用性
- 可用性:和放弃分区容错性相反,当遇到网络分区时,收到影响的服务就等待,此时可用性会降低
- 一致性:指的是**放弃数据的强一致性**,保证最终一致性,在一定时间内保证数据的最终一致

对于一个分布式系统,必然是要部署到不同的节点上,因此分区容错性是必须的,因此要在**一致性和可用性之间寻求平衡**



**Base理论:**

CAP中对可用性和一致性的权衡的结果,即使做不到强一致性,也要达到最终一致性

- **基本可用**:再出现不可预估的故障时,**允许损失一部分可用性**

  示例:

  - 正常情况下,一个搜索引擎0.5秒内返回数据,但是出现故障最终2秒返回

  - 双十一时,部分消费者会被引导到降级页面

- **软状态**:允许数据存在中间状态,,且不会影响系统的整体可用性,也就是**允许数据在不同节点之间存在延时**

- **最终一致性**:所有数据副本,经过一段时间的同步后,最终都能达到一致
  - **因果一致性**:如果进程**A在更新完某个数据项后**通知了进程B,那么进程B该数据项的访问都应该能够**获取到进程A更新后的最新值**，并且如果进程B要对该数据项更新的话，**务必基于进程A更新后的最新值**，即**不能发生丢失更新**情况。与进程A无因果关系的进程C的数据访问则没有这样的限制。
  - **读己之所写**:进程A更新一个数据项之后，它**自己访问到的是更新过的最新值**，而不会看到旧值。**特殊的因果一致性,B进程就是A进程**
  - **会话一致性**:系统能保证在**同一个有效的会话中**实现**“读己之所写”的一致性**，执行更新操作之后，客户端在同一个会话中始终读取到该数据项的最新值。
  - **单调读一致性**:一个进程从系统中读取出某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。
  - **单调写一致性**:一个系统需要能够保证来自**同一个进程的写操作被顺序地执行**。

### 总结

在实践中，可以将其中的若千个一致性变种互相结合起来，以构建一个具有**最终一致性特性**的分布式系统。事实上，最终一致性并不是只有那些大型分布式系统才涉及，许多现代的**关系型数据库**都采用了最终一致性模型,大多采用**同步和异步方式来实现主备数据复制**技术。在**同步方式中**，数据的**复制过程是更新事务的一部分**(也就是更新后同步的去复制数据了)，因此在事务完成后，主备数据库的数据就会达到一致。而在**异步方式中，备库的更新往往会存在延时**，这取决于**事务日志在主备数据库之间传输的时间长短**，如果**传输时间过长或者甚至在日志传输过程中出现异常**导致无法及时将事务应用到备库上，备库中读取的数据将是旧的，就出现了**数据不一致**的情况。当然，无论是采用多次重试还是人为数据订正，关系型数据库还是能够保证**最终数据达到一致**->这就是系统提供最终一致性保证的经典案例。
总的来说，**BASE理论面向的是大型高可用可扩展的分布式系统**，完全不同于ACID的强一致性模型，而是牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但**最终达到一致**状态。但同时，在实**际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同**的，因此在具体的分布式系统架构设计过程中，**ACID特性与BASE理论往往又会结合在一起使用**。



## 一致性算法

### 概述

分布式系统中，每一个节点能够明确地知道自己在进行事务过程中的结果是成功或失败，却无法获取到其他分布式节点的操作结果。因此，当一个事
务需要跨越多个分布式节点的时候，为了保持事务处理的ACID特性，就需要引人一个称为**“协调者”**的组件来**统一调度所有分布式节点的执行逻辑**，这
些**被调度的分布式节点则被称为“参与者”**。**协调者负责调度参与者的行为**，并最终**决定这些参与者是否要把事务真正进行提交**。基于这个思想，衔生出了二阶
段提交和三阶段提交两种协议

### 2PC

目前**绝大部分数据库都是2PC协议**

事务的提交过程被分为**两个阶段**:

**阶段一:提交事务请求**

1. 事务询问。
   协调者向所有的参与者发送事务内容，**询问是否可以执行事务提交操作**，并开始**等待各参与者的响应**。
2. 执行事务。
   各参与者执行事务操作，并将Undo和Redo信息记入事务日志中。
3. 各参与者向协调者反馈事务询问的响应。
   如果参与者成功执行事务，那么就反馈Yes，否则反馈No响应，表示事务不可以执行。

**阶段二:执行事务提交**
协调者会根据反馈情况来决定是否进行事务提交操作，
正常情况下，包含以下两种可能。

- 执行事务提交->假如协调者从**所有的参与者**获得的**反馈都是Yes响应**，那么就会**执行事务提交**。

  1. 发送提交请求。

     协调者向所有参与者节点发出Commit请求。

  2. 事务提交。
     参与者接收到Commit 请求后，会正式执行事务提交操作，并在完成提交之后释放占用的事务资源。
  3. 反馈事务提交结果。
     参与者在完成事务提交之后，**向协调者发送Ack消息**。
  4. 完成事务。
     协调者接收到所有参与者反馈的Ack消息后，完成事务。

- 中断事务
  假如**任何一个参与者反馈了No响应**，或者在等待超时之后，协调者尚**无法接收到所有参与者的反馈响应**，那么就会中断事务。

  1. 发送回滚请求。

     协调者向所有参与者节点发出Rollback请求。

  2. 事务回滚。
     参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执
     行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。
  3. 反馈事务回滚结果。
     参与者在完成事务回滚之后，向协调者发送Ack消息。
  4. 中断事务。
     协调者接收到所有参与者反馈的Ack消息后，完成事务中断。

二阶段提交将一个事务的处理过程分为了**投票和执行两个阶段**，其核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看作一个**强一致性**的算法

**优点:**原理简单，实现方便。
**缺点:**同步阻塞、单点问题、脑裂、太过保守。
**同步阻塞**:  极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。
**单点问题**:协调者起到了非常重要的作用。一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。

**数据不一致**:
阶段二，即执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了异常，导致最终只有部分参与者收到了Commit请求。于是，这部分
参与者就会进行事务的提交，参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致性现象。
**太过保守**:协调者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者**只能依靠其自身的超时机制**来判断是否需要中断事务。换句话说，二阶段提交协议没有较为完善的容错机制，**任意一个节点的失败都会导致整个事务的失败**。

### 3PC

在2PC的基础上把第一步分成两步,**2PC的第一步是询问且参与者执行事务,3PC分成了询问和执行两个步骤**

阶段一:CanCommit

1. 事务询问:协调者向所有的参与者发送一个**包含事务内容**的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。
2. **各参与者反馈事务询问的响应**。
   参与者如果其自身认为可以顺利执行事务，反馈Yes，否则反馈No。

阶段二: PreCommit
协调者会**根据反馈情况**来决定是否可以进行事务的PreCommit操作，包含两种可能。

- **执行事务预提交**->假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。

  1. 发送预提交请求。
     协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段。

  2. 事务预提交。
     参与者接收到preCommit请求后，会**执行事务操作**，并将Undo和Redo信息记录到事务日志中。

  2. 各参与者向协调者反馈事务执行的响应。
     如果参与者成功执行了事务操作，就会反馈给协调者Ack响应，**同时等待最终的指令**:提交(commit) 或中止(abort)。

- **中断事务**->假如任何一个参与者向反馈了No，或者在等待超时之后，协调者尚**无法接收到所有参与者**的反馈响应，就会中断事务。

  1. 发送中断请求。
     协调者向所有参与者节点发出abort请求。

  2. 中断事务。

     收到来自协调者的abort请求，或者等待协调者命令过程中出现超时，参与者都会中断事务。

**阶段三: doCommit**
进行真正的事务提交，会存在以下两种可能的情况。

- 执行提交

  1. 发送提交请求。
     假设协调者处于正常工作状态，并且接收到了来自所有参与者的Ack响应，那么它将从“预提交”状态转换到“提交”状态，并**向所有的**
     **参与者发送doCommit请求。**
  2. 事务提交。
     参与者接收到doCommit 请求后，会**正式执行事务提交操作**，完成之后释放占用的事务资源。
  3. 反馈事务提交结果。
     参与者在完成事务提交之后，**向协调者发送Ack消息**。
  4. 完成事务。
     协调者**接收到所有参与者反馈的Ack消息后**，完成事务。

- 中断事务

  假如**任何一个参与者反馈了No响应**，或者在等待超时之后，协调者尚**无法接收到所有参与者的反馈响应**，那么就会中断事务。

  1. 发送中断请求。
     协调者向所有的参与者节点发送abort请求。
  2. 事务回滚。
     **参与者**接收到abort请求后，会利用阶段二中记录的**Undo信息来执行事务回滚**操作，并在完成回滚之后释放占用的资源。

  3. 反馈事务回滚结果。
     参与者在完成事务回滚之后，向协调者发送Ack消息。

  4. 中断事务。

     协调者接收到所有参与者反馈的Ack消息后，中断事务。

需要注意的是，一旦进入阶段三，可能会存在以下两种故障。

- 协调者出现问题。

- 协调者和参与者之间的网络出现故障。

  都会导致参与者无法及时接收到来自协调者的doCommit或是abort请求，针对这样的异常情况，**参与者会在等待超时之后，继续进行事务提交**。

**优缺点:**
优点:**降低了参与者的阻塞范围**，并且**能够在出现单点故障后继续达成一致**。
缺点:参与者接收到preCommit消息后，如果网络出现分区，此时协调者和参与者无法进行正常的网络通信，在参与者依然会进行事务的提交，这必然
出现**数据的不一致性**。

### PAXOS算法

解决问题:在一个可能发生任何异常的分布式系统,快速且正确地在集群内部对某个数据的值达成一致，并且不会破坏整个系统的一致性。

#### 以前学过的paxos:

1. 提议者和接受者 1:1 如果提议者发出一个提议,接受者不接受,就没有值被接受 

   -> 接受者必须接受第一个提议

2. 提议者和接受者 3:3 提议者分别发出一个值不同的提议,三个接受者分别接受,就没有一个统一的值

   ->提议要被多数人接受

   ->接受者可以接受不同的提议,否则上一行的情况在3:3的情况下无法满足

   ->由于可以接受不同的提议,那么之后接受提议的值必须相等,不然接受不同的值没有意义->对接受者作出限制

3. 提议者A和接受者ABCDE达成共识,此时接受者F从宕机恢复(此时没有接受过提议),然后提议者B发出提议到接受者F,因为是第一个提议,就必须被接受,那么接受的值就不统一了

   ->提议者发出提议前先去**学习**是否有值达成共识,如果有,就只能发出这个包含值的提议->对提议者作出限制

因此推导出学习过程:

1. 提议者选择一个**新的提案编号N**，然后向**某个Acceptor集合**（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）。
   (a) 向Proposer承诺保证**不再接受**任何编号**小于N的提案(简单的说我预定了你这个最新的,以前旧的天不要了,但是要是有编号比你更大的,我还是会接受的)**。
   (b) 如果Acceptor已经接受过提案，那么就向Proposer响应**已经接受过**的编号小于N的**最大编号的提案(就是告诉你我接受了谁的提议)**。

   ->>>>总结一下,那么未响应过的任何**编号大于N**的Prepare请求的Acceptor,就可以接受N的提议

   我们将该请求称为**编号为N**的**Prepare请求**。

2. 如果Proposer收到了**半数以上**的Acceptor的**响应**，那么它就可以生成编号为N，Value为V的**提案[N,V]**。这里的V是所有的响应中**编号最大的提案的Value(这个值就是学习好的值)**。如果响应中**没有提案**，那 么此时值自己选择**。
   生成提案后，Proposer将该**提案**发送给**半数以上**的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为**Accept请求**。（注意：此时接受Accept请求的Acceptor集合**不一定是之前响应Prepare请求的Acceptor集合）

learner获得value的三种方案

![image-20220307170744673](../../Desktop/assets/image-20220307170744673.png)

**最后,为了Paxos算法的活性,就需要找到一个主提议者**

![幻灯片18.png](https://upload-images.jianshu.io/upload_images/1752522-28b18dd606777074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)