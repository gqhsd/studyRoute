## 线程关键字

## volatile的理解

1. 内存屏障和禁止指令重排序来保证可见性
   适用于根据标志决定是否执行/怎么执行的情况,也就是不对变量进行多次修改(**只有单个线程会对这个变量进行修改**)

   原因:

   1. 内存屏障是把处理的数据立即同步到主内存,程序根据实时更新的数据进行决定
   2. 然后根据 禁止指令重排序,顺序执行下一条指令,防止根据旧数据进行判定

2. 为什么不适用于对变量进行多次修改?

   原因: 例如i++,包含三个步骤,但在多线程情况下,他把i同时写进工作内存,虽然修改了之后立即同步到主内存,但是不同线程后续操作还是在工作内存中的数据完成的,依然会出现脏数据的情况

### volatile使用建议和场景

- volatile是轻量级同步机制：
  - 相对于synchronized块的代码锁，volatile应该是提供了一个轻量级的针对共享变量的锁，当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。
  - volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。
- volatile使用建议：
  - 在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。
  - 由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。





## 指令重排序 理解

```
对于在同一个线程内，这样的改变是不会对逻辑产生影响的，但是在多线程的情况下指令重排序会带来问题。看下面这个情景:

在线程A中:
context = loadContext();
inited = true;
在线程B中:
while(!inited ){ //根据线程A中对inited变量的修改决定是否使用context变量
sleep(100);
}
doSomethingwithconfig(context);

假设线程A中发生了指令重排序:
inited = true;
context = loadContext();
那么B中很可能就会拿到一个尚未初始化或尚未初始化完成的context,从而引发程序错误。
```



## Synchronized的使用

问题清单:

- Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。
- Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。
- Synchronized由什么样的缺陷?  Java Lock是怎么弥补这些缺陷的。
- Synchronized和Lock的对比，和选择?
- Synchronized在使用时有何注意事项?
- Synchronized修饰的方法在抛出异常时,会释放锁吗?
- 多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?
- Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?
- 我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?
- 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?
- 不同的JDK中对Synchronized有何优化?

### 理解

- 每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁
- synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁

### 对象锁:锁定的对象是类的实例,同一个线程同一时刻

包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)

####  











## volatile和synchronized的区别

- volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

- volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的

- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性

- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

  

















































































   