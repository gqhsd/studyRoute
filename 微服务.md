# 微服务

## 1 .需解决的问题

1. 在所有服务都是更小单元的部署结构时，一个请求需要调动更多的服务资源，怎样获得更好的性能？
2. 当业务规模增大，需要有地理分布不同的微服务集群时，其底层的数据存储集群是多数据中心还是单数据集群？
3. 数据存储如何进行数据复制？
4. 业务数据达到大数据量时怎样进行数据的分区？
5. 分布式事务怎样保证一致性？
6. 不同程度的一致性有什么差别？
7. 基于容器技术的服务发现怎么处理？
8. 应该用哪些 RPC 技术，用哪些分布式消息队列来完成服务通信和解耦？
9. 那么多的分布式技术框架、算法、服务应该选哪个才适合企业的业务场景？



**Paxos的推导过程**

1. 提议者和接受者 1:1 如果提议者发出一个提议,接受者不接受,就没有值被接受 

   -> 接受者必须接受第一个提议

2. 提议者和接受者 3:3 提议者分别发出一个值不同的提议,三个接受者分别接受,就没有一个统一的值

   ->提议要被多数人接受

   ->接受者可以接受不同的提议,否则上一行的情况在3:3的情况下无法满足

   ->由于可以接受不同的提议,那么之后接受提议的值必须相等,不然接受不同的值没有意义->对接受者作出限制

3. 提议者A和接受者ABCDE达成共识,此时接受者F从宕机恢复(此时没有接受过提议),然后提议者B发出提议到接受者F,因为是第一个提议,就必须被接受,那么接受的值就不统一了

   ->提议者发出提议前先去**学习**是否有值达成共识,如果有,就只能发出这个包含值的提议->对提议者作出限制

因此推导出学习过程:

1. 提议者选择一个**新的提案编号N**，然后向**某个Acceptor集合**（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）。
   (a) 向Proposer承诺保证**不再接受**任何编号**小于N的提案(简单的说我预定了你这个最新的,以前旧的天不要了,但是要是有编号比你更大的,我还是会接受的)**。
   (b) 如果Acceptor已经接受过提案，那么就向Proposer响应**已经接受过**的编号小于N的**最大编号的提案(就是告诉你我接受了谁的提议)**。

   ->>>>总结一下,那么未响应过的任何**编号大于N**的Prepare请求的Acceptor,就可以接受N的提议

   我们将该请求称为**编号为N**的**Prepare请求**。

2. 如果Proposer收到了**半数以上**的Acceptor的**响应**，那么它就可以生成编号为N，Value为V的**提案[N,V]**。这里的V是所有的响应中**编号最大的提案的Value(这个值就是学习好的值)**。如果响应中**没有提案**，那 么此时值自己选择**。
   生成提案后，Proposer将该**提案**发送给**半数以上**的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为**Accept请求**。（注意：此时接受Accept请求的Acceptor集合**不一定是之前响应Prepare请求的Acceptor集合）

learner获得value的三种方案

![image-20220307170744673](../../Desktop/assets/image-20220307170744673.png)

**最后,为了Paxos算法的活性,就需要找到一个主提议者**

![幻灯片18.png](https://upload-images.jianshu.io/upload_images/1752522-28b18dd606777074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)