# python

## 基础



### 数据结构

列表可以修改，而字符串和元组不能。



### 字典:

键唯一,且类型必须为不可变类型: 如数字,字符串,元组

字典内容是可以改变的,删除某项用del

清空内容用clear



### 集合

可以使用大括号 **{ }** 或者 **set()** 函数创建集合，注意：创建一个空集合必须用 **set()** 而不是 **{ }**，因为 **{ }** 是用来创建一个空字典。



**集合默认去重**



### is 与 == 区别：

is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。

```python
>>> a = [1, 2, 3]
>>> b = a
>>> b is a 
True
>>> b == a
True
>>> b = a[:]
>>> b is a
False
>>> b == a
True
```



### 赋值语句

**a, b = b, a+b** 的计算方式为先计算右边表达式，然后同时赋值给左边

```
n=b
m=a+b
a=n
b=m
```



### 命名空间和作用域

一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。

每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。

Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。

因此，如果要给函数内的全局变量赋值，必须使用 global 语句。

global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。

例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句前的注释符就能解决这个问题。

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
Money = 2000
def AddMoney():
   # 想改正代码就取消以下注释:
   # global Money
   Money = Money + 1
 
print Money
AddMoney()
print Money
```

### 关键字

nonlocal 用于修改上级函数的局部变量

global:修改全局变量



### 空对象

列表:[]

元组:()

集合:set()



### 参数

必须参数:传入的参数的数量必须一致,不然会报错

不定长参数:以*修饰的参数,以元组形式传入,可以使空元组

​					:加了两个星号 ***\*** 的参数会以字典的形式导入